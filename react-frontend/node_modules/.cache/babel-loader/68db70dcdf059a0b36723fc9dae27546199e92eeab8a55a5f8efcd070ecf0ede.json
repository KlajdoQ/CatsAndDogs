{"ast":null,"code":"var adapters = {\n  logger: self.console,\n  WebSocket: self.WebSocket\n};\nvar logger = {\n  log() {\n    if (this.enabled) {\n      for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n        messages[_key] = arguments[_key];\n      }\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};\nconst now = () => new Date().getTime();\nconst secondsSince = time => (now() - time) / 1e3;\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordPing() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    this.recordPing();\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale();\n      this.poll();\n    }, this.getPollInterval());\n  }\n  getPollInterval() {\n    const {\n      staleThreshold: staleThreshold,\n      reconnectionBackoffRate: reconnectionBackoffRate\n    } = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }, 200);\n    }\n  }\n}\nConnectionMonitor.staleThreshold = 6;\nConnectionMonitor.reconnectionBackoffRate = .15;\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n};\nconst {\n  message_types: message_types,\n  protocols: protocols\n} = INTERNAL;\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\nconst indexOf = [].indexOf;\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, protocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close() {\n    let {\n      allowReconnect: allowReconnect\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      allowReconnect: true\n    };\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState() {\n    for (var _len2 = arguments.length, states = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      states[_key2] = arguments[_key2];\n    }\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function () {};\n    }\n  }\n}\nConnection.reopenDelay = 500;\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const {\n      identifier: identifier,\n      message: message,\n      reason: reason,\n      reconnect: reconnect,\n      type: type\n    } = JSON.parse(event.data);\n    switch (type) {\n      case message_types.welcome:\n        this.monitor.recordConnect();\n        return this.subscriptions.reload();\n      case message_types.disconnect:\n        logger.log(`Disconnecting. Reason: ${reason}`);\n        return this.close({\n          allowReconnect: reconnect\n        });\n      case message_types.ping:\n        return this.monitor.recordPing();\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier);\n        return this.subscriptions.notify(identifier, \"connected\");\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier);\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\nconst extend = function (object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\nclass Subscription {\n  constructor(consumer) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let mixin = arguments.length > 2 ? arguments[2] : undefined;\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n  perform(action) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter(s => s !== subscription);\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout(() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map(subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        });\n      }\n    }, 500);\n  }\n}\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map(subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    });\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter(s => s !== subscription);\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter(s => s.identifier === identifier);\n  }\n  reload() {\n    return this.subscriptions.map(subscription => this.subscribe(subscription));\n  }\n  notifyAll(callbackName) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return this.subscriptions.map(subscription => this.notify(subscription, callbackName, ...args));\n  }\n  notify(subscription, callbackName) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n      args[_key4 - 2] = arguments[_key4];\n    }\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [subscription];\n    }\n    return subscriptions.map(subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined);\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map(subscription => this.guarantor.forget(subscription));\n  }\n  sendCommand(subscription, command) {\n    const {\n      identifier: identifier\n    } = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n}\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n}\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\nfunction createConsumer() {\n  let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getConfig(\"url\") || INTERNAL.default_mount_path;\n  return new Consumer(url);\n}\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };","map":{"version":3,"names":["adapters","logger","self","console","WebSocket","log","enabled","messages","push","Date","now","getTime","secondsSince","time","ConnectionMonitor","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","staleThreshold","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","reconnectionBackoffRate","backoff","Math","pow","min","jitterMax","jitter","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","document","visibilityState","isOpen","INTERNAL","message_types","welcome","disconnect","ping","confirmation","rejection","disconnect_reasons","unauthorized","invalid_request","server_restart","default_mount_path","protocols","supportedProtocols","slice","length","indexOf","Connection","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","uninstallEventHandlers","url","installEventHandlers","close","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","identifier","reason","reconnect","type","parse","reload","confirmSubscription","notify","reject","notifyAll","willAttemptReconnect","extend","object","properties","key","value","Subscription","params","mixin","perform","action","command","unsubscribe","remove","SubscriptionGuarantor","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","Subscriptions","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","undefined","Consumer","_url","createWebSocketURL","connect","test","a","createElement","href","replace","createConsumer","getConfig","name","element","head","querySelector","getAttribute"],"sources":["/Users/kqasolli/Desktop/capstone/CatsAndDogs/react-frontend/node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js"],"sourcesContent":["var adapters = {\n  logger: self.console,\n  WebSocket: self.WebSocket\n};\n\nvar logger = {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};\n\nconst now = () => (new Date).getTime();\n\nconst secondsSince = time => (now() - time) / 1e3;\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordPing() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    this.recordPing();\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout((() => {\n      this.reconnectIfStale();\n      this.poll();\n    }), this.getPollInterval());\n  }\n  getPollInterval() {\n    const {staleThreshold: staleThreshold, reconnectionBackoffRate: reconnectionBackoffRate} = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout((() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }), 200);\n    }\n  }\n}\n\nConnectionMonitor.staleThreshold = 6;\n\nConnectionMonitor.reconnectionBackoffRate = .15;\n\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [ \"actioncable-v1-json\", \"actioncable-unsupported\" ]\n};\n\nconst {message_types: message_types, protocols: protocols} = INTERNAL;\n\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\n\nconst indexOf = [].indexOf;\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, protocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close({allowReconnect: allowReconnect} = {\n    allowReconnect: true\n  }) {\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {};\n    }\n  }\n}\n\nConnection.reopenDelay = 500;\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const {identifier: identifier, message: message, reason: reason, reconnect: reconnect, type: type} = JSON.parse(event.data);\n    switch (type) {\n     case message_types.welcome:\n      this.monitor.recordConnect();\n      return this.subscriptions.reload();\n\n     case message_types.disconnect:\n      logger.log(`Disconnecting. Reason: ${reason}`);\n      return this.close({\n        allowReconnect: reconnect\n      });\n\n     case message_types.ping:\n      return this.monitor.recordPing();\n\n     case message_types.confirmation:\n      this.subscriptions.confirmSubscription(identifier);\n      return this.subscriptions.notify(identifier, \"connected\");\n\n     case message_types.rejection:\n      return this.subscriptions.reject(identifier);\n\n     default:\n      return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\n\nclass Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n  perform(action, data = {}) {\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter((s => s !== subscription));\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout((() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map((subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        }));\n      }\n    }), 500);\n  }\n}\n\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    }));\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter((s => s !== subscription));\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter((s => s.identifier === identifier));\n  }\n  reload() {\n    return this.subscriptions.map((subscription => this.subscribe(subscription)));\n  }\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription => this.notify(subscription, callbackName, ...args)));\n  }\n  notify(subscription, callbackName, ...args) {\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [ subscription ];\n    }\n    return subscriptions.map((subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined));\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map((subscription => this.guarantor.forget(subscription)));\n  }\n  sendCommand(subscription, command) {\n    const {identifier: identifier} = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n}\n\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n}\n\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\n\nfunction createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url);\n}\n\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\n\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}